###############################################################################
# fuel_suppliers/rho_star_test.R
#
# PURPOSE
#   Formalize the argument that negative within-sector rho values in small
#   sectors are consistent with a common positive underlying rho (rho*).
#
#   For each proxy variant and each N_min cutoff {5, 10, 15, 30}:
#   1. Split sectors into "large" (n_firms >= N_min) and "small" (< N_min)
#   2. Find the largest rho* such that:
#      (a) We reject H0: rho_s <= rho* for ALL large sectors (5% one-sided)
#      (b) Small sectors satisfy a tolerance condition (see variants below)
#
#   Test variants:
#     strict_1sd:     ALL small sectors within 1 SD of rho*
#     strict_2sd:     ALL small sectors within 2 SD of rho*
#     relaxed_1sd_80: >= 80% of small sectors within 1 SD of rho*
#     relaxed_2sd_80: >= 80% of small sectors within 2 SD of rho*
#
#   Variance: Var(rho_s) = 1/(n_firms - 1)  [conservative: treats within-firm
#   observations as fully dependent, so effective n = n_firms not n_firmyears]
#
# INPUT
#   {OUTPUT_DIR}/rho_pooled_sector_comparison.csv
#   (generated by phase2a_rho_analysis.R)
#
# OUTPUT
#   Console: detailed test results + summary table
#   {OUTPUT_DIR}/rho_star_test_results.csv
###############################################################################

# ── Paths ────────────────────────────────────────────────────────────────────
if (tolower(Sys.info()[["user"]]) == "jardang") {
  REPO_DIR <- "C:/Users/jardang/Documents/inferring_emissions"
} else if (tolower(Sys.info()[["user"]]) == "jota_"){
  REPO_DIR <- tryCatch(dirname(normalizePath(sys.frame(1)$ofile, winslash = "/")),
                        error = function(e) normalizePath(getwd(), winslash = "/"))
  while (!file.exists(file.path(REPO_DIR, "paths.R"))) REPO_DIR <- dirname(REPO_DIR)
} else {
  stop("Define REPO_DIR for this user.")
}
source(file.path(REPO_DIR, "paths.R"))


# ── Load data ────────────────────────────────────────────────────────────────
input_fn <- file.path(OUTPUT_DIR, "rho_pooled_sector_comparison.csv")
if (!file.exists(input_fn)) {
  stop("Input file not found: ", input_fn, "\n",
       "Run phase2a_rho_analysis.R first to generate it.")
}

comp <- read.csv(input_fn, stringsAsFactors = FALSE)
cat("Loaded", nrow(comp), "sectors from", basename(input_fn), "\n\n")


# ── Test parameters ──────────────────────────────────────────────────────────
N_MIN_CUTS <- c(5, 10, 15, 20, 30)
ALPHA      <- 0.05
Z_ALPHA    <- qnorm(1 - ALPHA)   # 1.645 for 5% one-sided

# Proxy variants to test (column names from the comp CSV)
proxies <- list(
  list(name = "pooled",   rho_col = "rho_pooled_pooled",  n_col = "n_firms_pooled"),
  list(name = "weighted", rho_col = "rho_pooled_weighted", n_col = "n_firms_weighted")
)

# Test configurations: (k_sd, min_fraction)
test_configs <- list(
  list(label = "strict_1sd",     k_sd = 1, min_frac = 1.00),
  list(label = "strict_2sd",     k_sd = 2, min_frac = 1.00),
  list(label = "relaxed_1sd_80", k_sd = 1, min_frac = 0.80),
  list(label = "relaxed_2sd_80", k_sd = 2, min_frac = 0.80)
)


# ── Core test function ──────────────────────────────────────────────────────
#
# Given large/small sector data, k_sd, and min_frac:
# 1. UB_large = min_{large s} { rho_hat_s - z_alpha / sqrt(n_s - 1) }
# 2. For each small sector s, acceptable rho* interval:
#      [rho_hat_s - k * SD_s, rho_hat_s + k * SD_s]
# 3. Find largest rho* <= UB_large with >= ceil(min_frac * n_small) sectors OK
#
find_rho_star <- function(sectors, n_min, z_alpha, k_sd, min_frac) {
  large <- sectors[sectors$n_firms >= n_min, ]
  small <- sectors[sectors$n_firms <  n_min, ]

  res <- list(
    n_min = n_min, n_large = nrow(large), n_small = nrow(small),
    rho_star = NA_real_, feasible = FALSE,
    n_ok = 0L, frac_ok = NA_real_,
    binding = "", binding_sector = "",
    ub_large = NA_real_
  )

  if (nrow(large) == 0) {
    res$binding <- "NO_LARGE_SECTORS"
    res$large_detail <- large
    res$small_detail <- small
    return(res)
  }

  # SD and upper bounds for large sectors
  large$sd <- 1 / sqrt(large$n_firms - 1)
  large$ub <- large$rho_hat - z_alpha * large$sd
  ub_large <- min(large$ub)
  binding_large <- large$nace2d[which.min(large$ub)]

  res$ub_large <- ub_large

  if (nrow(small) == 0) {
    res$rho_star <- ub_large
    res$feasible <- TRUE
    res$n_ok     <- 0L
    res$frac_ok  <- 1.0
    res$binding  <- "large"
    res$binding_sector <- binding_large
    res$large_detail <- large
    res$small_detail <- small
    return(res)
  }

  # Intervals for small sectors
  small$sd     <- 1 / sqrt(pmax(small$n_firms - 1, 1))
  small$int_lb <- small$rho_hat - k_sd * small$sd
  small$int_ub <- small$rho_hat + k_sd * small$sd

  threshold <- ceiling(min_frac * nrow(small))

  # Candidate rho* values: all interval endpoints + UB_large, sorted descending
  # The count of "OK" sectors is piecewise constant between consecutive
  # endpoints, so the optimum is at one of them.
  candidates <- sort(unique(c(small$int_lb, small$int_ub, ub_large)),
                     decreasing = TRUE)
  candidates <- candidates[candidates <= ub_large + 1e-12]

  best_rho_star <- NA_real_
  best_n_ok     <- 0L

  for (rho_cand in candidates) {
    rho_cand <- min(rho_cand, ub_large)  # enforce large-sector constraint
    n_ok <- sum(small$int_lb <= rho_cand + 1e-12 &
                rho_cand <= small$int_ub + 1e-12)
    if (n_ok >= threshold) {
      best_rho_star <- rho_cand
      best_n_ok     <- n_ok
      break
    }
    # Track best count even if below threshold
    if (n_ok > best_n_ok) {
      best_n_ok     <- n_ok
      best_rho_star <- rho_cand
    }
  }

  feasible <- !is.na(best_rho_star) && best_n_ok >= threshold
  res$rho_star <- best_rho_star
  res$feasible <- feasible
  res$n_ok     <- best_n_ok
  res$frac_ok  <- best_n_ok / nrow(small)

  # Determine binding constraint
  if (feasible && best_rho_star >= ub_large - 1e-12) {
    res$binding <- "large"
    res$binding_sector <- binding_large
  } else if (feasible) {
    # Binding from small-sector upper bound
    violators_ub <- small[small$int_ub <= ub_large + 1e-12, ]
    if (nrow(violators_ub) > 0) {
      res$binding <- "small_ub"
      res$binding_sector <- violators_ub$nace2d[which.min(violators_ub$int_ub)]
    } else {
      res$binding <- "large"
      res$binding_sector <- binding_large
    }
  } else {
    res$binding <- "INFEASIBLE"
    res$binding_sector <- ""
  }

  # Store which small sectors are OK at the chosen rho*
  if (!is.na(best_rho_star)) {
    small$within_band <- (small$int_lb <= best_rho_star + 1e-12 &
                          best_rho_star <= small$int_ub + 1e-12)
  } else {
    small$within_band <- FALSE
  }

  res$large_detail <- large
  res$small_detail <- small

  return(res)
}


# ── Run all tests ────────────────────────────────────────────────────────────
summary_rows <- list()

for (prx in proxies) {
  cat("\n")
  cat(strrep("=", 75), "\n")
  cat(sprintf("PROXY: %s\n", toupper(prx$name)))
  cat(strrep("=", 75), "\n")

  sectors <- data.frame(
    nace2d  = comp$nace2d,
    n_firms = comp[[prx$n_col]],
    rho_hat = comp[[prx$rho_col]],
    stringsAsFactors = FALSE
  )
  sectors <- sectors[!is.na(sectors$rho_hat), ]

  cat(sprintf("\nTotal sectors: %d\n", nrow(sectors)))
  cat(sprintf("Variance: Var(rho) = 1/(n_firms - 1)  [conservative]\n"))
  cat(sprintf("Rejection: alpha = %.2f, z_alpha = %.3f (one-sided)\n", ALPHA, Z_ALPHA))

  for (n_min in N_MIN_CUTS) {
    cat(sprintf("\n%s\n", strrep("-", 75)))
    cat(sprintf("N_min = %d\n", n_min))
    cat(sprintf("%s\n", strrep("-", 75)))

    n_large <- sum(sectors$n_firms >= n_min)
    n_small <- sum(sectors$n_firms <  n_min)
    cat(sprintf("\n  Large (>= %d firms): %d sectors\n", n_min, n_large))
    cat(sprintf("  Small (<  %d firms): %d sectors\n", n_min, n_small))

    if (n_large == 0) {
      cat("  No large sectors -- skipping.\n")
      for (tc in test_configs) {
        summary_rows[[length(summary_rows) + 1]] <- data.frame(
          proxy = prx$name, n_min = n_min, test = tc$label,
          n_large = 0, n_small = n_small,
          rho_star = NA, feasible = NA, frac_ok = NA,
          n_ok = NA, binding = "NO_LARGE", binding_sector = "",
          stringsAsFactors = FALSE)
      }
      next
    }

    for (tc in test_configs) {
      cat(sprintf("\n  ── %s (k=%d SD, require >= %.0f%% of small sectors) ──\n",
                  tc$label, tc$k_sd, 100 * tc$min_frac))

      res <- find_rho_star(sectors, n_min, Z_ALPHA, tc$k_sd, tc$min_frac)

      # Print large sector detail (only for first test config to avoid repetition)
      if (tc$label == test_configs[[1]]$label) {
        cat("\n  Large sectors:\n")
        cat(sprintf("  %-6s  %6s  %10s  %10s  %15s\n",
                    "NACE", "Firms", "rho_hat", "SD", "UB=rho-z*SD"))
        cat("  ", strrep("-", 53), "\n")
        ld <- res$large_detail[order(res$large_detail$ub), ]
        for (i in seq_len(nrow(ld))) {
          r <- ld[i, ]
          cat(sprintf("  %-6s  %6d  %10.3f  %10.3f  %15.3f\n",
                      r$nace2d, r$n_firms, r$rho_hat, r$sd, r$ub))
        }
        cat(sprintf("\n  UB from large sectors = %.3f\n", res$ub_large))
      }

      # Print small sector detail
      if (res$n_small > 0 && !is.na(res$rho_star)) {
        cat(sprintf("\n  Small sectors (rho* = %.3f, %d SD band):\n",
                    res$rho_star, tc$k_sd))
        cat(sprintf("  %-6s  %6s  %10s  %10s  %12s  %12s  %5s\n",
                    "NACE", "Firms", "rho_hat", "SD",
                    sprintf("rho*-%dSD", tc$k_sd),
                    sprintf("rho*+%dSD", tc$k_sd), "OK?"))
        cat("  ", strrep("-", 63), "\n")
        sd <- res$small_detail[order(res$small_detail$rho_hat), ]
        for (i in seq_len(nrow(sd))) {
          r <- sd[i, ]
          lo <- res$rho_star - tc$k_sd * r$sd
          hi <- res$rho_star + tc$k_sd * r$sd
          cat(sprintf("  %-6s  %6d  %10.3f  %10.3f  %12.3f  %12.3f  %5s\n",
                      r$nace2d, r$n_firms, r$rho_hat, r$sd, lo, hi,
                      if (r$within_band) "yes" else "NO"))
        }
        cat(sprintf("\n  Within band: %d / %d (%.0f%%)\n",
                    res$n_ok, res$n_small, 100 * res$frac_ok))
      }

      # Result
      feas_label <- if (is.na(res$feasible)) "N/A"
                    else if (res$feasible) "YES" else "NO"
      rho_label  <- if (is.na(res$rho_star)) "N/A"
                    else sprintf("%.3f", res$rho_star)

      cat(sprintf("\n  ==> rho* = %s  |  Feasible: %s", rho_label, feas_label))
      if (res$feasible) {
        cat(sprintf("  |  Binding: NACE %s (%s)", res$binding_sector, res$binding))
      }
      cat("\n")

      # Store summary
      summary_rows[[length(summary_rows) + 1]] <- data.frame(
        proxy    = prx$name,
        n_min    = n_min,
        test     = tc$label,
        n_large  = res$n_large,
        n_small  = res$n_small,
        rho_star = if (!is.na(res$rho_star)) round(res$rho_star, 4) else NA,
        feasible = res$feasible,
        frac_ok  = if (!is.na(res$frac_ok)) round(res$frac_ok, 3) else NA,
        n_ok     = res$n_ok,
        binding  = res$binding,
        binding_sector = res$binding_sector,
        stringsAsFactors = FALSE
      )
    }
  }
}


# ── Summary table ────────────────────────────────────────────────────────────
cat("\n\n")
cat(strrep("=", 95), "\n")
cat("SUMMARY: rho* by proxy, N_min, and test variant\n")
cat(strrep("=", 95), "\n\n")

summary_df <- do.call(rbind, summary_rows)

cat(sprintf("%-9s  %5s  %-16s  %5s  %5s  %8s  %8s  %7s  %12s  %8s\n",
            "Proxy", "N_min", "Test", "Large", "Small", "rho*", "Feasible",
            "Frac_OK", "Binding", "Sector"))
cat(strrep("-", 95), "\n")
for (i in seq_len(nrow(summary_df))) {
  r <- summary_df[i, ]
  rho_str  <- if (is.na(r$rho_star)) sprintf("%8s", "N/A") else sprintf("%8.3f", r$rho_star)
  feas_str <- if (is.na(r$feasible)) "N/A" else if (r$feasible) "YES" else "NO"
  frac_str <- if (is.na(r$frac_ok)) sprintf("%7s", "N/A") else sprintf("%6.0f%%", 100 * r$frac_ok)
  cat(sprintf("%-9s  %5d  %-16s  %5d  %5d  %s  %8s  %7s  %12s  %8s\n",
              r$proxy, r$n_min, r$test, r$n_large, r$n_small,
              rho_str, feas_str, frac_str, r$binding, r$binding_sector))
}


# ── Save ─────────────────────────────────────────────────────────────────────
if (!dir.exists(OUTPUT_DIR)) dir.create(OUTPUT_DIR, recursive = TRUE)
out_fn <- file.path(OUTPUT_DIR, "rho_star_test_results.csv")
write.csv(summary_df, out_fn, row.names = FALSE)
cat(sprintf("\nSaved: %s\n", out_fn))

cat("\nDone.\n")
